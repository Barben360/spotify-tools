/*
Spotify Web API with fixes and improvements from sonallux

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 2023.2.27
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spotifyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// TracksApiService TracksApi service
type TracksApiService service

type TracksApiAddTracksToPlaylistRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	position *int32
	uris *string
	requestBody *map[string]interface{}
}

func (r TracksApiAddTracksToPlaylistRequest) Position(position int32) TracksApiAddTracksToPlaylistRequest {
	r.position = &position
	return r
}

func (r TracksApiAddTracksToPlaylistRequest) Uris(uris string) TracksApiAddTracksToPlaylistRequest {
	r.uris = &uris
	return r
}

func (r TracksApiAddTracksToPlaylistRequest) RequestBody(requestBody map[string]interface{}) TracksApiAddTracksToPlaylistRequest {
	r.requestBody = &requestBody
	return r
}

func (r TracksApiAddTracksToPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.AddTracksToPlaylistExecute(r)
}

/*
AddTracksToPlaylist Add Items to Playlist 

Add one or more items to a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return TracksApiAddTracksToPlaylistRequest
*/
func (a *TracksApiService) AddTracksToPlaylist(ctx context.Context, playlistId string) TracksApiAddTracksToPlaylistRequest {
	return TracksApiAddTracksToPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) AddTracksToPlaylistExecute(r TracksApiAddTracksToPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.AddTracksToPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "")
	}
	if r.uris != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiCheckUsersSavedTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
}

func (r TracksApiCheckUsersSavedTracksRequest) Ids(ids string) TracksApiCheckUsersSavedTracksRequest {
	r.ids = &ids
	return r
}

func (r TracksApiCheckUsersSavedTracksRequest) Execute() ([]bool, *http.Response, error) {
	return r.ApiService.CheckUsersSavedTracksExecute(r)
}

/*
CheckUsersSavedTracks Check User's Saved Tracks 

Check if one or more tracks is already saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiCheckUsersSavedTracksRequest
*/
func (a *TracksApiService) CheckUsersSavedTracks(ctx context.Context) TracksApiCheckUsersSavedTracksRequest {
	return TracksApiCheckUsersSavedTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []bool
func (a *TracksApiService) CheckUsersSavedTracksExecute(r TracksApiCheckUsersSavedTracksRequest) ([]bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.CheckUsersSavedTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks/contains"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetAnAlbumsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
	limit *int32
	offset *int32
}

func (r TracksApiGetAnAlbumsTracksRequest) Market(market string) TracksApiGetAnAlbumsTracksRequest {
	r.market = &market
	return r
}

func (r TracksApiGetAnAlbumsTracksRequest) Limit(limit int32) TracksApiGetAnAlbumsTracksRequest {
	r.limit = &limit
	return r
}

func (r TracksApiGetAnAlbumsTracksRequest) Offset(offset int32) TracksApiGetAnAlbumsTracksRequest {
	r.offset = &offset
	return r
}

func (r TracksApiGetAnAlbumsTracksRequest) Execute() (*PagingSimplifiedTrackObject, *http.Response, error) {
	return r.ApiService.GetAnAlbumsTracksExecute(r)
}

/*
GetAnAlbumsTracks Get Album Tracks 

Get Spotify catalog information about an album’s tracks.
Optional parameters can be used to limit the number of tracks returned.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return TracksApiGetAnAlbumsTracksRequest
*/
func (a *TracksApiService) GetAnAlbumsTracks(ctx context.Context, id string) TracksApiGetAnAlbumsTracksRequest {
	return TracksApiGetAnAlbumsTracksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return PagingSimplifiedTrackObject
func (a *TracksApiService) GetAnAlbumsTracksExecute(r TracksApiGetAnAlbumsTracksRequest) (*PagingSimplifiedTrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingSimplifiedTrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAnAlbumsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/albums/{id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetAnArtistsTopTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
}

func (r TracksApiGetAnArtistsTopTracksRequest) Market(market string) TracksApiGetAnArtistsTopTracksRequest {
	r.market = &market
	return r
}

func (r TracksApiGetAnArtistsTopTracksRequest) Execute() (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	return r.ApiService.GetAnArtistsTopTracksExecute(r)
}

/*
GetAnArtistsTopTracks Get Artist's Top Tracks 

Get Spotify catalog information about an artist's top tracks by country.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return TracksApiGetAnArtistsTopTracksRequest
*/
func (a *TracksApiService) GetAnArtistsTopTracks(ctx context.Context, id string) TracksApiGetAnArtistsTopTracksRequest {
	return TracksApiGetAnArtistsTopTracksRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return GetAnArtistsTopTracks200Response
func (a *TracksApiService) GetAnArtistsTopTracksExecute(r TracksApiGetAnArtistsTopTracksRequest) (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnArtistsTopTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAnArtistsTopTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/artists/{id}/top-tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetAudioAnalysisRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
}

func (r TracksApiGetAudioAnalysisRequest) Execute() (*AudioAnalysisObject, *http.Response, error) {
	return r.ApiService.GetAudioAnalysisExecute(r)
}

/*
GetAudioAnalysis Get Track's Audio Analysis 

Get a low-level audio analysis for a track in the Spotify catalog. The audio analysis describes the track’s structure and musical content, including rhythm, pitch, and timbre.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return TracksApiGetAudioAnalysisRequest
*/
func (a *TracksApiService) GetAudioAnalysis(ctx context.Context, id string) TracksApiGetAudioAnalysisRequest {
	return TracksApiGetAudioAnalysisRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AudioAnalysisObject
func (a *TracksApiService) GetAudioAnalysisExecute(r TracksApiGetAudioAnalysisRequest) (*AudioAnalysisObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudioAnalysisObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAudioAnalysis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-analysis/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetAudioFeaturesRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
}

func (r TracksApiGetAudioFeaturesRequest) Execute() (*AudioFeaturesObject, *http.Response, error) {
	return r.ApiService.GetAudioFeaturesExecute(r)
}

/*
GetAudioFeatures Get Track's Audio Features 

Get audio feature information for a single track identified by its unique
Spotify ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return TracksApiGetAudioFeaturesRequest
*/
func (a *TracksApiService) GetAudioFeatures(ctx context.Context, id string) TracksApiGetAudioFeaturesRequest {
	return TracksApiGetAudioFeaturesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return AudioFeaturesObject
func (a *TracksApiService) GetAudioFeaturesExecute(r TracksApiGetAudioFeaturesRequest) (*AudioFeaturesObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudioFeaturesObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetAudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-features/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetPlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	market *string
	fields *string
	limit *int32
	offset *int32
	additionalTypes *string
}

func (r TracksApiGetPlaylistsTracksRequest) Market(market string) TracksApiGetPlaylistsTracksRequest {
	r.market = &market
	return r
}

func (r TracksApiGetPlaylistsTracksRequest) Fields(fields string) TracksApiGetPlaylistsTracksRequest {
	r.fields = &fields
	return r
}

func (r TracksApiGetPlaylistsTracksRequest) Limit(limit int32) TracksApiGetPlaylistsTracksRequest {
	r.limit = &limit
	return r
}

func (r TracksApiGetPlaylistsTracksRequest) Offset(offset int32) TracksApiGetPlaylistsTracksRequest {
	r.offset = &offset
	return r
}

func (r TracksApiGetPlaylistsTracksRequest) AdditionalTypes(additionalTypes string) TracksApiGetPlaylistsTracksRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r TracksApiGetPlaylistsTracksRequest) Execute() (*PagingPlaylistTrackObject, *http.Response, error) {
	return r.ApiService.GetPlaylistsTracksExecute(r)
}

/*
GetPlaylistsTracks Get Playlist Items 

Get full details of the items of a playlist owned by a Spotify user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return TracksApiGetPlaylistsTracksRequest
*/
func (a *TracksApiService) GetPlaylistsTracks(ctx context.Context, playlistId string) TracksApiGetPlaylistsTracksRequest {
	return TracksApiGetPlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return PagingPlaylistTrackObject
func (a *TracksApiService) GetPlaylistsTracksExecute(r TracksApiGetPlaylistsTracksRequest) (*PagingPlaylistTrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingPlaylistTrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetPlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.additionalTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_types", r.additionalTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetRecommendationsRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	limit *int32
	market *string
	seedArtists *string
	seedGenres *string
	seedTracks *string
	minAcousticness *float32
	maxAcousticness *float32
	targetAcousticness *float32
	minDanceability *float32
	maxDanceability *float32
	targetDanceability *float32
	minDurationMs *int32
	maxDurationMs *int32
	targetDurationMs *int32
	minEnergy *float32
	maxEnergy *float32
	targetEnergy *float32
	minInstrumentalness *float32
	maxInstrumentalness *float32
	targetInstrumentalness *float32
	minKey *int32
	maxKey *int32
	targetKey *int32
	minLiveness *float32
	maxLiveness *float32
	targetLiveness *float32
	minLoudness *float32
	maxLoudness *float32
	targetLoudness *float32
	minMode *int32
	maxMode *int32
	targetMode *int32
	minPopularity *int32
	maxPopularity *int32
	targetPopularity *int32
	minSpeechiness *float32
	maxSpeechiness *float32
	targetSpeechiness *float32
	minTempo *float32
	maxTempo *float32
	targetTempo *float32
	minTimeSignature *int32
	maxTimeSignature *int32
	targetTimeSignature *int32
	minValence *float32
	maxValence *float32
	targetValence *float32
}

func (r TracksApiGetRecommendationsRequest) Limit(limit int32) TracksApiGetRecommendationsRequest {
	r.limit = &limit
	return r
}

func (r TracksApiGetRecommendationsRequest) Market(market string) TracksApiGetRecommendationsRequest {
	r.market = &market
	return r
}

func (r TracksApiGetRecommendationsRequest) SeedArtists(seedArtists string) TracksApiGetRecommendationsRequest {
	r.seedArtists = &seedArtists
	return r
}

func (r TracksApiGetRecommendationsRequest) SeedGenres(seedGenres string) TracksApiGetRecommendationsRequest {
	r.seedGenres = &seedGenres
	return r
}

func (r TracksApiGetRecommendationsRequest) SeedTracks(seedTracks string) TracksApiGetRecommendationsRequest {
	r.seedTracks = &seedTracks
	return r
}

func (r TracksApiGetRecommendationsRequest) MinAcousticness(minAcousticness float32) TracksApiGetRecommendationsRequest {
	r.minAcousticness = &minAcousticness
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxAcousticness(maxAcousticness float32) TracksApiGetRecommendationsRequest {
	r.maxAcousticness = &maxAcousticness
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetAcousticness(targetAcousticness float32) TracksApiGetRecommendationsRequest {
	r.targetAcousticness = &targetAcousticness
	return r
}

func (r TracksApiGetRecommendationsRequest) MinDanceability(minDanceability float32) TracksApiGetRecommendationsRequest {
	r.minDanceability = &minDanceability
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxDanceability(maxDanceability float32) TracksApiGetRecommendationsRequest {
	r.maxDanceability = &maxDanceability
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetDanceability(targetDanceability float32) TracksApiGetRecommendationsRequest {
	r.targetDanceability = &targetDanceability
	return r
}

func (r TracksApiGetRecommendationsRequest) MinDurationMs(minDurationMs int32) TracksApiGetRecommendationsRequest {
	r.minDurationMs = &minDurationMs
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxDurationMs(maxDurationMs int32) TracksApiGetRecommendationsRequest {
	r.maxDurationMs = &maxDurationMs
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetDurationMs(targetDurationMs int32) TracksApiGetRecommendationsRequest {
	r.targetDurationMs = &targetDurationMs
	return r
}

func (r TracksApiGetRecommendationsRequest) MinEnergy(minEnergy float32) TracksApiGetRecommendationsRequest {
	r.minEnergy = &minEnergy
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxEnergy(maxEnergy float32) TracksApiGetRecommendationsRequest {
	r.maxEnergy = &maxEnergy
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetEnergy(targetEnergy float32) TracksApiGetRecommendationsRequest {
	r.targetEnergy = &targetEnergy
	return r
}

func (r TracksApiGetRecommendationsRequest) MinInstrumentalness(minInstrumentalness float32) TracksApiGetRecommendationsRequest {
	r.minInstrumentalness = &minInstrumentalness
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxInstrumentalness(maxInstrumentalness float32) TracksApiGetRecommendationsRequest {
	r.maxInstrumentalness = &maxInstrumentalness
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetInstrumentalness(targetInstrumentalness float32) TracksApiGetRecommendationsRequest {
	r.targetInstrumentalness = &targetInstrumentalness
	return r
}

func (r TracksApiGetRecommendationsRequest) MinKey(minKey int32) TracksApiGetRecommendationsRequest {
	r.minKey = &minKey
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxKey(maxKey int32) TracksApiGetRecommendationsRequest {
	r.maxKey = &maxKey
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetKey(targetKey int32) TracksApiGetRecommendationsRequest {
	r.targetKey = &targetKey
	return r
}

func (r TracksApiGetRecommendationsRequest) MinLiveness(minLiveness float32) TracksApiGetRecommendationsRequest {
	r.minLiveness = &minLiveness
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxLiveness(maxLiveness float32) TracksApiGetRecommendationsRequest {
	r.maxLiveness = &maxLiveness
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetLiveness(targetLiveness float32) TracksApiGetRecommendationsRequest {
	r.targetLiveness = &targetLiveness
	return r
}

func (r TracksApiGetRecommendationsRequest) MinLoudness(minLoudness float32) TracksApiGetRecommendationsRequest {
	r.minLoudness = &minLoudness
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxLoudness(maxLoudness float32) TracksApiGetRecommendationsRequest {
	r.maxLoudness = &maxLoudness
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetLoudness(targetLoudness float32) TracksApiGetRecommendationsRequest {
	r.targetLoudness = &targetLoudness
	return r
}

func (r TracksApiGetRecommendationsRequest) MinMode(minMode int32) TracksApiGetRecommendationsRequest {
	r.minMode = &minMode
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxMode(maxMode int32) TracksApiGetRecommendationsRequest {
	r.maxMode = &maxMode
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetMode(targetMode int32) TracksApiGetRecommendationsRequest {
	r.targetMode = &targetMode
	return r
}

func (r TracksApiGetRecommendationsRequest) MinPopularity(minPopularity int32) TracksApiGetRecommendationsRequest {
	r.minPopularity = &minPopularity
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxPopularity(maxPopularity int32) TracksApiGetRecommendationsRequest {
	r.maxPopularity = &maxPopularity
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetPopularity(targetPopularity int32) TracksApiGetRecommendationsRequest {
	r.targetPopularity = &targetPopularity
	return r
}

func (r TracksApiGetRecommendationsRequest) MinSpeechiness(minSpeechiness float32) TracksApiGetRecommendationsRequest {
	r.minSpeechiness = &minSpeechiness
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxSpeechiness(maxSpeechiness float32) TracksApiGetRecommendationsRequest {
	r.maxSpeechiness = &maxSpeechiness
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetSpeechiness(targetSpeechiness float32) TracksApiGetRecommendationsRequest {
	r.targetSpeechiness = &targetSpeechiness
	return r
}

func (r TracksApiGetRecommendationsRequest) MinTempo(minTempo float32) TracksApiGetRecommendationsRequest {
	r.minTempo = &minTempo
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxTempo(maxTempo float32) TracksApiGetRecommendationsRequest {
	r.maxTempo = &maxTempo
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetTempo(targetTempo float32) TracksApiGetRecommendationsRequest {
	r.targetTempo = &targetTempo
	return r
}

func (r TracksApiGetRecommendationsRequest) MinTimeSignature(minTimeSignature int32) TracksApiGetRecommendationsRequest {
	r.minTimeSignature = &minTimeSignature
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxTimeSignature(maxTimeSignature int32) TracksApiGetRecommendationsRequest {
	r.maxTimeSignature = &maxTimeSignature
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetTimeSignature(targetTimeSignature int32) TracksApiGetRecommendationsRequest {
	r.targetTimeSignature = &targetTimeSignature
	return r
}

func (r TracksApiGetRecommendationsRequest) MinValence(minValence float32) TracksApiGetRecommendationsRequest {
	r.minValence = &minValence
	return r
}

func (r TracksApiGetRecommendationsRequest) MaxValence(maxValence float32) TracksApiGetRecommendationsRequest {
	r.maxValence = &maxValence
	return r
}

func (r TracksApiGetRecommendationsRequest) TargetValence(targetValence float32) TracksApiGetRecommendationsRequest {
	r.targetValence = &targetValence
	return r
}

func (r TracksApiGetRecommendationsRequest) Execute() (*RecommendationsObject, *http.Response, error) {
	return r.ApiService.GetRecommendationsExecute(r)
}

/*
GetRecommendations Get Recommendations 

Recommendations are generated based on the available information for a given seed entity and matched against similar artists and tracks. If there is sufficient information about the provided seeds, a list of tracks will be returned together with pool size details.

For artists and tracks that are very new or obscure there might not be enough data to generate a list of tracks.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiGetRecommendationsRequest
*/
func (a *TracksApiService) GetRecommendations(ctx context.Context) TracksApiGetRecommendationsRequest {
	return TracksApiGetRecommendationsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RecommendationsObject
func (a *TracksApiService) GetRecommendationsExecute(r TracksApiGetRecommendationsRequest) (*RecommendationsObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RecommendationsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetRecommendations")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/recommendations"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.seedArtists != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seed_artists", r.seedArtists, "")
	}
	if r.seedGenres != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seed_genres", r.seedGenres, "")
	}
	if r.seedTracks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seed_tracks", r.seedTracks, "")
	}
	if r.minAcousticness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_acousticness", r.minAcousticness, "")
	}
	if r.maxAcousticness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_acousticness", r.maxAcousticness, "")
	}
	if r.targetAcousticness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_acousticness", r.targetAcousticness, "")
	}
	if r.minDanceability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_danceability", r.minDanceability, "")
	}
	if r.maxDanceability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_danceability", r.maxDanceability, "")
	}
	if r.targetDanceability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_danceability", r.targetDanceability, "")
	}
	if r.minDurationMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_duration_ms", r.minDurationMs, "")
	}
	if r.maxDurationMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_duration_ms", r.maxDurationMs, "")
	}
	if r.targetDurationMs != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_duration_ms", r.targetDurationMs, "")
	}
	if r.minEnergy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_energy", r.minEnergy, "")
	}
	if r.maxEnergy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_energy", r.maxEnergy, "")
	}
	if r.targetEnergy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_energy", r.targetEnergy, "")
	}
	if r.minInstrumentalness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_instrumentalness", r.minInstrumentalness, "")
	}
	if r.maxInstrumentalness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_instrumentalness", r.maxInstrumentalness, "")
	}
	if r.targetInstrumentalness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_instrumentalness", r.targetInstrumentalness, "")
	}
	if r.minKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_key", r.minKey, "")
	}
	if r.maxKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_key", r.maxKey, "")
	}
	if r.targetKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_key", r.targetKey, "")
	}
	if r.minLiveness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_liveness", r.minLiveness, "")
	}
	if r.maxLiveness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_liveness", r.maxLiveness, "")
	}
	if r.targetLiveness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_liveness", r.targetLiveness, "")
	}
	if r.minLoudness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_loudness", r.minLoudness, "")
	}
	if r.maxLoudness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_loudness", r.maxLoudness, "")
	}
	if r.targetLoudness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_loudness", r.targetLoudness, "")
	}
	if r.minMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_mode", r.minMode, "")
	}
	if r.maxMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_mode", r.maxMode, "")
	}
	if r.targetMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_mode", r.targetMode, "")
	}
	if r.minPopularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_popularity", r.minPopularity, "")
	}
	if r.maxPopularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_popularity", r.maxPopularity, "")
	}
	if r.targetPopularity != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_popularity", r.targetPopularity, "")
	}
	if r.minSpeechiness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_speechiness", r.minSpeechiness, "")
	}
	if r.maxSpeechiness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_speechiness", r.maxSpeechiness, "")
	}
	if r.targetSpeechiness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_speechiness", r.targetSpeechiness, "")
	}
	if r.minTempo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_tempo", r.minTempo, "")
	}
	if r.maxTempo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_tempo", r.maxTempo, "")
	}
	if r.targetTempo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_tempo", r.targetTempo, "")
	}
	if r.minTimeSignature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_time_signature", r.minTimeSignature, "")
	}
	if r.maxTimeSignature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_time_signature", r.maxTimeSignature, "")
	}
	if r.targetTimeSignature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_time_signature", r.targetTimeSignature, "")
	}
	if r.minValence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "min_valence", r.minValence, "")
	}
	if r.maxValence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "max_valence", r.maxValence, "")
	}
	if r.targetValence != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "target_valence", r.targetValence, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetSeveralAudioFeaturesRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
}

func (r TracksApiGetSeveralAudioFeaturesRequest) Ids(ids string) TracksApiGetSeveralAudioFeaturesRequest {
	r.ids = &ids
	return r
}

func (r TracksApiGetSeveralAudioFeaturesRequest) Execute() (*GetSeveralAudioFeatures200Response, *http.Response, error) {
	return r.ApiService.GetSeveralAudioFeaturesExecute(r)
}

/*
GetSeveralAudioFeatures Get Tracks' Audio Features 

Get audio features for multiple tracks based on their Spotify IDs.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiGetSeveralAudioFeaturesRequest
*/
func (a *TracksApiService) GetSeveralAudioFeatures(ctx context.Context) TracksApiGetSeveralAudioFeaturesRequest {
	return TracksApiGetSeveralAudioFeaturesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetSeveralAudioFeatures200Response
func (a *TracksApiService) GetSeveralAudioFeaturesExecute(r TracksApiGetSeveralAudioFeaturesRequest) (*GetSeveralAudioFeatures200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetSeveralAudioFeatures200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetSeveralAudioFeatures")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/audio-features"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetSeveralTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	market *string
}

func (r TracksApiGetSeveralTracksRequest) Ids(ids string) TracksApiGetSeveralTracksRequest {
	r.ids = &ids
	return r
}

func (r TracksApiGetSeveralTracksRequest) Market(market string) TracksApiGetSeveralTracksRequest {
	r.market = &market
	return r
}

func (r TracksApiGetSeveralTracksRequest) Execute() (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	return r.ApiService.GetSeveralTracksExecute(r)
}

/*
GetSeveralTracks Get Several Tracks 

Get Spotify catalog information for multiple tracks based on their Spotify IDs.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiGetSeveralTracksRequest
*/
func (a *TracksApiService) GetSeveralTracks(ctx context.Context) TracksApiGetSeveralTracksRequest {
	return TracksApiGetSeveralTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetAnArtistsTopTracks200Response
func (a *TracksApiService) GetSeveralTracksExecute(r TracksApiGetSeveralTracksRequest) (*GetAnArtistsTopTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetAnArtistsTopTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetSeveralTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetTrackRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	id string
	market *string
}

func (r TracksApiGetTrackRequest) Market(market string) TracksApiGetTrackRequest {
	r.market = &market
	return r
}

func (r TracksApiGetTrackRequest) Execute() (*TrackObject, *http.Response, error) {
	return r.ApiService.GetTrackExecute(r)
}

/*
GetTrack Get Track 

Get Spotify catalog information for a single track identified by its
unique Spotify ID.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return TracksApiGetTrackRequest
*/
func (a *TracksApiService) GetTrack(ctx context.Context, id string) TracksApiGetTrackRequest {
	return TracksApiGetTrackRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return TrackObject
func (a *TracksApiService) GetTrackExecute(r TracksApiGetTrackRequest) (*TrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetTrack")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/tracks/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetUsersSavedTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	market *string
	limit *int32
	offset *int32
}

func (r TracksApiGetUsersSavedTracksRequest) Market(market string) TracksApiGetUsersSavedTracksRequest {
	r.market = &market
	return r
}

func (r TracksApiGetUsersSavedTracksRequest) Limit(limit int32) TracksApiGetUsersSavedTracksRequest {
	r.limit = &limit
	return r
}

func (r TracksApiGetUsersSavedTracksRequest) Offset(offset int32) TracksApiGetUsersSavedTracksRequest {
	r.offset = &offset
	return r
}

func (r TracksApiGetUsersSavedTracksRequest) Execute() (*PagingSavedTrackObject, *http.Response, error) {
	return r.ApiService.GetUsersSavedTracksExecute(r)
}

/*
GetUsersSavedTracks Get User's Saved Tracks 

Get a list of the songs saved in the current Spotify user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiGetUsersSavedTracksRequest
*/
func (a *TracksApiService) GetUsersSavedTracks(ctx context.Context) TracksApiGetUsersSavedTracksRequest {
	return TracksApiGetUsersSavedTracksRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagingSavedTrackObject
func (a *TracksApiService) GetUsersSavedTracksExecute(r TracksApiGetUsersSavedTracksRequest) (*PagingSavedTrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingSavedTrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetUsersSavedTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiGetUsersTopArtistsAndTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	type_ string
	timeRange *string
	limit *int32
	offset *int32
}

func (r TracksApiGetUsersTopArtistsAndTracksRequest) TimeRange(timeRange string) TracksApiGetUsersTopArtistsAndTracksRequest {
	r.timeRange = &timeRange
	return r
}

func (r TracksApiGetUsersTopArtistsAndTracksRequest) Limit(limit int32) TracksApiGetUsersTopArtistsAndTracksRequest {
	r.limit = &limit
	return r
}

func (r TracksApiGetUsersTopArtistsAndTracksRequest) Offset(offset int32) TracksApiGetUsersTopArtistsAndTracksRequest {
	r.offset = &offset
	return r
}

func (r TracksApiGetUsersTopArtistsAndTracksRequest) Execute() (*GetUsersTopArtistsAndTracks200Response, *http.Response, error) {
	return r.ApiService.GetUsersTopArtistsAndTracksExecute(r)
}

/*
GetUsersTopArtistsAndTracks Get User's Top Items 

Get the current user's top artists or tracks based on calculated affinity.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param type_
 @return TracksApiGetUsersTopArtistsAndTracksRequest
*/
func (a *TracksApiService) GetUsersTopArtistsAndTracks(ctx context.Context, type_ string) TracksApiGetUsersTopArtistsAndTracksRequest {
	return TracksApiGetUsersTopArtistsAndTracksRequest{
		ApiService: a,
		ctx: ctx,
		type_: type_,
	}
}

// Execute executes the request
//  @return GetUsersTopArtistsAndTracks200Response
func (a *TracksApiService) GetUsersTopArtistsAndTracksExecute(r TracksApiGetUsersTopArtistsAndTracksRequest) (*GetUsersTopArtistsAndTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetUsersTopArtistsAndTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.GetUsersTopArtistsAndTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/top/{type}"
	localVarPath = strings.Replace(localVarPath, "{"+"type"+"}", url.PathEscape(parameterValueToString(r.type_, "type_")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.timeRange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "time_range", r.timeRange, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiRemoveTracksPlaylistRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	removeTracksPlaylistRequest *RemoveTracksPlaylistRequest
}

func (r TracksApiRemoveTracksPlaylistRequest) RemoveTracksPlaylistRequest(removeTracksPlaylistRequest RemoveTracksPlaylistRequest) TracksApiRemoveTracksPlaylistRequest {
	r.removeTracksPlaylistRequest = &removeTracksPlaylistRequest
	return r
}

func (r TracksApiRemoveTracksPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.RemoveTracksPlaylistExecute(r)
}

/*
RemoveTracksPlaylist Remove Playlist Items 

Remove one or more items from a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return TracksApiRemoveTracksPlaylistRequest
*/
func (a *TracksApiService) RemoveTracksPlaylist(ctx context.Context, playlistId string) TracksApiRemoveTracksPlaylistRequest {
	return TracksApiRemoveTracksPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) RemoveTracksPlaylistExecute(r TracksApiRemoveTracksPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.RemoveTracksPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeTracksPlaylistRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiRemoveTracksUserRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	requestBody *map[string]interface{}
}

func (r TracksApiRemoveTracksUserRequest) Ids(ids string) TracksApiRemoveTracksUserRequest {
	r.ids = &ids
	return r
}

func (r TracksApiRemoveTracksUserRequest) RequestBody(requestBody map[string]interface{}) TracksApiRemoveTracksUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r TracksApiRemoveTracksUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveTracksUserExecute(r)
}

/*
RemoveTracksUser Remove User's Saved Tracks 

Remove one or more tracks from the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiRemoveTracksUserRequest
*/
func (a *TracksApiService) RemoveTracksUser(ctx context.Context) TracksApiRemoveTracksUserRequest {
	return TracksApiRemoveTracksUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TracksApiService) RemoveTracksUserExecute(r TracksApiRemoveTracksUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.RemoveTracksUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type TracksApiReorderOrReplacePlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	playlistId string
	uris *string
	requestBody *map[string]interface{}
}

func (r TracksApiReorderOrReplacePlaylistsTracksRequest) Uris(uris string) TracksApiReorderOrReplacePlaylistsTracksRequest {
	r.uris = &uris
	return r
}

func (r TracksApiReorderOrReplacePlaylistsTracksRequest) RequestBody(requestBody map[string]interface{}) TracksApiReorderOrReplacePlaylistsTracksRequest {
	r.requestBody = &requestBody
	return r
}

func (r TracksApiReorderOrReplacePlaylistsTracksRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.ReorderOrReplacePlaylistsTracksExecute(r)
}

/*
ReorderOrReplacePlaylistsTracks Update Playlist Items 

Either reorder or replace items in a playlist depending on the request's parameters.
To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request's body.
To replace items, include `uris` as either a query parameter or in the request's body.
Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist.
<br/>
**Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters.
These operations can't be applied together in a single request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return TracksApiReorderOrReplacePlaylistsTracksRequest
*/
func (a *TracksApiService) ReorderOrReplacePlaylistsTracks(ctx context.Context, playlistId string) TracksApiReorderOrReplacePlaylistsTracksRequest {
	return TracksApiReorderOrReplacePlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *TracksApiService) ReorderOrReplacePlaylistsTracksExecute(r TracksApiReorderOrReplacePlaylistsTracksRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.ReorderOrReplacePlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uris != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type TracksApiSaveTracksUserRequest struct {
	ctx context.Context
	ApiService *TracksApiService
	ids *string
	requestBody *map[string]interface{}
}

func (r TracksApiSaveTracksUserRequest) Ids(ids string) TracksApiSaveTracksUserRequest {
	r.ids = &ids
	return r
}

func (r TracksApiSaveTracksUserRequest) RequestBody(requestBody map[string]interface{}) TracksApiSaveTracksUserRequest {
	r.requestBody = &requestBody
	return r
}

func (r TracksApiSaveTracksUserRequest) Execute() (*http.Response, error) {
	return r.ApiService.SaveTracksUserExecute(r)
}

/*
SaveTracksUser Save Tracks for Current User 

Save one or more tracks to the current user's 'Your Music' library.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return TracksApiSaveTracksUserRequest
*/
func (a *TracksApiService) SaveTracksUser(ctx context.Context) TracksApiSaveTracksUserRequest {
	return TracksApiSaveTracksUserRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *TracksApiService) SaveTracksUserExecute(r TracksApiSaveTracksUserRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TracksApiService.SaveTracksUser")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/tracks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
