/*
Spotify Web API with fixes and improvements from sonallux

You can use Spotify's Web API to discover music and podcasts, manage your Spotify library, control audio playback, and much more. Browse our available Web API endpoints using the sidebar at left, or via the navigation bar on top of this page on smaller screens.  In order to make successful Web API requests your app will need a valid access token. One can be obtained through <a href=\"https://developer.spotify.com/documentation/general/guides/authorization-guide/\">OAuth 2.0</a>.  The base URI for all Web API requests is `https://api.spotify.com/v1`.  Need help? See our <a href=\"https://developer.spotify.com/documentation/web-api/guides/\">Web API guides</a> for more information, or visit the <a href=\"https://community.spotify.com/t5/Spotify-for-Developers/bd-p/Spotify_Developer\">Spotify for Developers community forum</a> to ask questions and connect with other developers. 

API version: 2023.2.27
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package spotifyclient

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// PlaylistsApiService PlaylistsApi service
type PlaylistsApiService service

type PlaylistsApiAddTracksToPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	position *int32
	uris *string
	requestBody *map[string]interface{}
}

func (r PlaylistsApiAddTracksToPlaylistRequest) Position(position int32) PlaylistsApiAddTracksToPlaylistRequest {
	r.position = &position
	return r
}

func (r PlaylistsApiAddTracksToPlaylistRequest) Uris(uris string) PlaylistsApiAddTracksToPlaylistRequest {
	r.uris = &uris
	return r
}

func (r PlaylistsApiAddTracksToPlaylistRequest) RequestBody(requestBody map[string]interface{}) PlaylistsApiAddTracksToPlaylistRequest {
	r.requestBody = &requestBody
	return r
}

func (r PlaylistsApiAddTracksToPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.AddTracksToPlaylistExecute(r)
}

/*
AddTracksToPlaylist Add Items to Playlist 

Add one or more items to a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiAddTracksToPlaylistRequest
*/
func (a *PlaylistsApiService) AddTracksToPlaylist(ctx context.Context, playlistId string) PlaylistsApiAddTracksToPlaylistRequest {
	return PlaylistsApiAddTracksToPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *PlaylistsApiService) AddTracksToPlaylistExecute(r PlaylistsApiAddTracksToPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.AddTracksToPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "")
	}
	if r.uris != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiChangePlaylistDetailsRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	requestBody *map[string]interface{}
}

func (r PlaylistsApiChangePlaylistDetailsRequest) RequestBody(requestBody map[string]interface{}) PlaylistsApiChangePlaylistDetailsRequest {
	r.requestBody = &requestBody
	return r
}

func (r PlaylistsApiChangePlaylistDetailsRequest) Execute() (*http.Response, error) {
	return r.ApiService.ChangePlaylistDetailsExecute(r)
}

/*
ChangePlaylistDetails Change Playlist Details 

Change a playlist's name and public/private state. (The user must, of
course, own the playlist.)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiChangePlaylistDetailsRequest
*/
func (a *PlaylistsApiService) ChangePlaylistDetails(ctx context.Context, playlistId string) PlaylistsApiChangePlaylistDetailsRequest {
	return PlaylistsApiChangePlaylistDetailsRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
func (a *PlaylistsApiService) ChangePlaylistDetailsExecute(r PlaylistsApiChangePlaylistDetailsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.ChangePlaylistDetails")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaylistsApiCheckIfUserFollowsPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	ids *string
}

func (r PlaylistsApiCheckIfUserFollowsPlaylistRequest) Ids(ids string) PlaylistsApiCheckIfUserFollowsPlaylistRequest {
	r.ids = &ids
	return r
}

func (r PlaylistsApiCheckIfUserFollowsPlaylistRequest) Execute() ([]bool, *http.Response, error) {
	return r.ApiService.CheckIfUserFollowsPlaylistExecute(r)
}

/*
CheckIfUserFollowsPlaylist Check if Users Follow Playlist 

Check to see if one or more Spotify users are following a specified playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiCheckIfUserFollowsPlaylistRequest
*/
func (a *PlaylistsApiService) CheckIfUserFollowsPlaylist(ctx context.Context, playlistId string) PlaylistsApiCheckIfUserFollowsPlaylistRequest {
	return PlaylistsApiCheckIfUserFollowsPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return []bool
func (a *PlaylistsApiService) CheckIfUserFollowsPlaylistExecute(r PlaylistsApiCheckIfUserFollowsPlaylistRequest) ([]bool, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []bool
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.CheckIfUserFollowsPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/followers/contains"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ids == nil {
		return localVarReturnValue, nil, reportError("ids is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiCreatePlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	userId string
	requestBody *map[string]interface{}
}

func (r PlaylistsApiCreatePlaylistRequest) RequestBody(requestBody map[string]interface{}) PlaylistsApiCreatePlaylistRequest {
	r.requestBody = &requestBody
	return r
}

func (r PlaylistsApiCreatePlaylistRequest) Execute() (*PlaylistObject, *http.Response, error) {
	return r.ApiService.CreatePlaylistExecute(r)
}

/*
CreatePlaylist Create Playlist 

Create a playlist for a Spotify user. (The playlist will be empty until
you [add tracks](/documentation/web-api/reference/add-tracks-to-playlist).)


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return PlaylistsApiCreatePlaylistRequest
*/
func (a *PlaylistsApiService) CreatePlaylist(ctx context.Context, userId string) PlaylistsApiCreatePlaylistRequest {
	return PlaylistsApiCreatePlaylistRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return PlaylistObject
func (a *PlaylistsApiService) CreatePlaylistExecute(r PlaylistsApiCreatePlaylistRequest) (*PlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.CreatePlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/playlists"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiFollowPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	requestBody *map[string]interface{}
}

func (r PlaylistsApiFollowPlaylistRequest) RequestBody(requestBody map[string]interface{}) PlaylistsApiFollowPlaylistRequest {
	r.requestBody = &requestBody
	return r
}

func (r PlaylistsApiFollowPlaylistRequest) Execute() (*http.Response, error) {
	return r.ApiService.FollowPlaylistExecute(r)
}

/*
FollowPlaylist Follow Playlist 

Add the current user as a follower of a playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiFollowPlaylistRequest
*/
func (a *PlaylistsApiService) FollowPlaylist(ctx context.Context, playlistId string) PlaylistsApiFollowPlaylistRequest {
	return PlaylistsApiFollowPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
func (a *PlaylistsApiService) FollowPlaylistExecute(r PlaylistsApiFollowPlaylistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.FollowPlaylist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/followers"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaylistsApiGetACategoriesPlaylistsRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	categoryId string
	country *string
	limit *int32
	offset *int32
}

func (r PlaylistsApiGetACategoriesPlaylistsRequest) Country(country string) PlaylistsApiGetACategoriesPlaylistsRequest {
	r.country = &country
	return r
}

func (r PlaylistsApiGetACategoriesPlaylistsRequest) Limit(limit int32) PlaylistsApiGetACategoriesPlaylistsRequest {
	r.limit = &limit
	return r
}

func (r PlaylistsApiGetACategoriesPlaylistsRequest) Offset(offset int32) PlaylistsApiGetACategoriesPlaylistsRequest {
	r.offset = &offset
	return r
}

func (r PlaylistsApiGetACategoriesPlaylistsRequest) Execute() (*PagingFeaturedPlaylistObject, *http.Response, error) {
	return r.ApiService.GetACategoriesPlaylistsExecute(r)
}

/*
GetACategoriesPlaylists Get Category's Playlists 

Get a list of Spotify playlists tagged with a particular category.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param categoryId
 @return PlaylistsApiGetACategoriesPlaylistsRequest
*/
func (a *PlaylistsApiService) GetACategoriesPlaylists(ctx context.Context, categoryId string) PlaylistsApiGetACategoriesPlaylistsRequest {
	return PlaylistsApiGetACategoriesPlaylistsRequest{
		ApiService: a,
		ctx: ctx,
		categoryId: categoryId,
	}
}

// Execute executes the request
//  @return PagingFeaturedPlaylistObject
func (a *PlaylistsApiService) GetACategoriesPlaylistsExecute(r PlaylistsApiGetACategoriesPlaylistsRequest) (*PagingFeaturedPlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingFeaturedPlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetACategoriesPlaylists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/browse/categories/{category_id}/playlists"
	localVarPath = strings.Replace(localVarPath, "{"+"category_id"+"}", url.PathEscape(parameterValueToString(r.categoryId, "categoryId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	limit *int32
	offset *int32
}

func (r PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest) Limit(limit int32) PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest {
	r.limit = &limit
	return r
}

func (r PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest) Offset(offset int32) PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest {
	r.offset = &offset
	return r
}

func (r PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest) Execute() (*PagingPlaylistObject, *http.Response, error) {
	return r.ApiService.GetAListOfCurrentUsersPlaylistsExecute(r)
}

/*
GetAListOfCurrentUsersPlaylists Get Current User's Playlists 

Get a list of the playlists owned or followed by the current Spotify
user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest
*/
func (a *PlaylistsApiService) GetAListOfCurrentUsersPlaylists(ctx context.Context) PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest {
	return PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagingPlaylistObject
func (a *PlaylistsApiService) GetAListOfCurrentUsersPlaylistsExecute(r PlaylistsApiGetAListOfCurrentUsersPlaylistsRequest) (*PagingPlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingPlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetAListOfCurrentUsersPlaylists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/me/playlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetFeaturedPlaylistsRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	country *string
	locale *string
	timestamp *string
	limit *int32
	offset *int32
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Country(country string) PlaylistsApiGetFeaturedPlaylistsRequest {
	r.country = &country
	return r
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Locale(locale string) PlaylistsApiGetFeaturedPlaylistsRequest {
	r.locale = &locale
	return r
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Timestamp(timestamp string) PlaylistsApiGetFeaturedPlaylistsRequest {
	r.timestamp = &timestamp
	return r
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Limit(limit int32) PlaylistsApiGetFeaturedPlaylistsRequest {
	r.limit = &limit
	return r
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Offset(offset int32) PlaylistsApiGetFeaturedPlaylistsRequest {
	r.offset = &offset
	return r
}

func (r PlaylistsApiGetFeaturedPlaylistsRequest) Execute() (*PagingFeaturedPlaylistObject, *http.Response, error) {
	return r.ApiService.GetFeaturedPlaylistsExecute(r)
}

/*
GetFeaturedPlaylists Get Featured Playlists 

Get a list of Spotify featured playlists (shown, for example, on a Spotify player's 'Browse' tab).


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PlaylistsApiGetFeaturedPlaylistsRequest
*/
func (a *PlaylistsApiService) GetFeaturedPlaylists(ctx context.Context) PlaylistsApiGetFeaturedPlaylistsRequest {
	return PlaylistsApiGetFeaturedPlaylistsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagingFeaturedPlaylistObject
func (a *PlaylistsApiService) GetFeaturedPlaylistsExecute(r PlaylistsApiGetFeaturedPlaylistsRequest) (*PagingFeaturedPlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingFeaturedPlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetFeaturedPlaylists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/browse/featured-playlists"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "")
	}
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetListUsersPlaylistsRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	userId string
	limit *int32
	offset *int32
}

func (r PlaylistsApiGetListUsersPlaylistsRequest) Limit(limit int32) PlaylistsApiGetListUsersPlaylistsRequest {
	r.limit = &limit
	return r
}

func (r PlaylistsApiGetListUsersPlaylistsRequest) Offset(offset int32) PlaylistsApiGetListUsersPlaylistsRequest {
	r.offset = &offset
	return r
}

func (r PlaylistsApiGetListUsersPlaylistsRequest) Execute() (*PagingPlaylistObject, *http.Response, error) {
	return r.ApiService.GetListUsersPlaylistsExecute(r)
}

/*
GetListUsersPlaylists Get User's Playlists 

Get a list of the playlists owned or followed by a Spotify user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId
 @return PlaylistsApiGetListUsersPlaylistsRequest
*/
func (a *PlaylistsApiService) GetListUsersPlaylists(ctx context.Context, userId string) PlaylistsApiGetListUsersPlaylistsRequest {
	return PlaylistsApiGetListUsersPlaylistsRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return PagingPlaylistObject
func (a *PlaylistsApiService) GetListUsersPlaylistsExecute(r PlaylistsApiGetListUsersPlaylistsRequest) (*PagingPlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingPlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetListUsersPlaylists")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{user_id}/playlists"
	localVarPath = strings.Replace(localVarPath, "{"+"user_id"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	market *string
	fields *string
	additionalTypes *string
}

func (r PlaylistsApiGetPlaylistRequest) Market(market string) PlaylistsApiGetPlaylistRequest {
	r.market = &market
	return r
}

func (r PlaylistsApiGetPlaylistRequest) Fields(fields string) PlaylistsApiGetPlaylistRequest {
	r.fields = &fields
	return r
}

func (r PlaylistsApiGetPlaylistRequest) AdditionalTypes(additionalTypes string) PlaylistsApiGetPlaylistRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r PlaylistsApiGetPlaylistRequest) Execute() (*PlaylistObject, *http.Response, error) {
	return r.ApiService.GetPlaylistExecute(r)
}

/*
GetPlaylist Get Playlist 

Get a playlist owned by a Spotify user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiGetPlaylistRequest
*/
func (a *PlaylistsApiService) GetPlaylist(ctx context.Context, playlistId string) PlaylistsApiGetPlaylistRequest {
	return PlaylistsApiGetPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return PlaylistObject
func (a *PlaylistsApiService) GetPlaylistExecute(r PlaylistsApiGetPlaylistRequest) (*PlaylistObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlaylistObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.additionalTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_types", r.additionalTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetPlaylistCoverRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
}

func (r PlaylistsApiGetPlaylistCoverRequest) Execute() ([]ImageObject, *http.Response, error) {
	return r.ApiService.GetPlaylistCoverExecute(r)
}

/*
GetPlaylistCover Get Playlist Cover Image 

Get the current image associated with a specific playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiGetPlaylistCoverRequest
*/
func (a *PlaylistsApiService) GetPlaylistCover(ctx context.Context, playlistId string) PlaylistsApiGetPlaylistCoverRequest {
	return PlaylistsApiGetPlaylistCoverRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return []ImageObject
func (a *PlaylistsApiService) GetPlaylistCoverExecute(r PlaylistsApiGetPlaylistCoverRequest) ([]ImageObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ImageObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetPlaylistCover")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiGetPlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	market *string
	fields *string
	limit *int32
	offset *int32
	additionalTypes *string
}

func (r PlaylistsApiGetPlaylistsTracksRequest) Market(market string) PlaylistsApiGetPlaylistsTracksRequest {
	r.market = &market
	return r
}

func (r PlaylistsApiGetPlaylistsTracksRequest) Fields(fields string) PlaylistsApiGetPlaylistsTracksRequest {
	r.fields = &fields
	return r
}

func (r PlaylistsApiGetPlaylistsTracksRequest) Limit(limit int32) PlaylistsApiGetPlaylistsTracksRequest {
	r.limit = &limit
	return r
}

func (r PlaylistsApiGetPlaylistsTracksRequest) Offset(offset int32) PlaylistsApiGetPlaylistsTracksRequest {
	r.offset = &offset
	return r
}

func (r PlaylistsApiGetPlaylistsTracksRequest) AdditionalTypes(additionalTypes string) PlaylistsApiGetPlaylistsTracksRequest {
	r.additionalTypes = &additionalTypes
	return r
}

func (r PlaylistsApiGetPlaylistsTracksRequest) Execute() (*PagingPlaylistTrackObject, *http.Response, error) {
	return r.ApiService.GetPlaylistsTracksExecute(r)
}

/*
GetPlaylistsTracks Get Playlist Items 

Get full details of the items of a playlist owned by a Spotify user.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiGetPlaylistsTracksRequest
*/
func (a *PlaylistsApiService) GetPlaylistsTracks(ctx context.Context, playlistId string) PlaylistsApiGetPlaylistsTracksRequest {
	return PlaylistsApiGetPlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return PagingPlaylistTrackObject
func (a *PlaylistsApiService) GetPlaylistsTracksExecute(r PlaylistsApiGetPlaylistsTracksRequest) (*PagingPlaylistTrackObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagingPlaylistTrackObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.GetPlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.market != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "market", r.market, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "")
	}
	if r.additionalTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "additional_types", r.additionalTypes, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiRemoveTracksPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	removeTracksPlaylistRequest *RemoveTracksPlaylistRequest
}

func (r PlaylistsApiRemoveTracksPlaylistRequest) RemoveTracksPlaylistRequest(removeTracksPlaylistRequest RemoveTracksPlaylistRequest) PlaylistsApiRemoveTracksPlaylistRequest {
	r.removeTracksPlaylistRequest = &removeTracksPlaylistRequest
	return r
}

func (r PlaylistsApiRemoveTracksPlaylistRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.RemoveTracksPlaylistExecute(r)
}

/*
RemoveTracksPlaylist Remove Playlist Items 

Remove one or more items from a user's playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiRemoveTracksPlaylistRequest
*/
func (a *PlaylistsApiService) RemoveTracksPlaylist(ctx context.Context, playlistId string) PlaylistsApiRemoveTracksPlaylistRequest {
	return PlaylistsApiRemoveTracksPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *PlaylistsApiService) RemoveTracksPlaylistExecute(r PlaylistsApiRemoveTracksPlaylistRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.RemoveTracksPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeTracksPlaylistRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiReorderOrReplacePlaylistsTracksRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	uris *string
	requestBody *map[string]interface{}
}

func (r PlaylistsApiReorderOrReplacePlaylistsTracksRequest) Uris(uris string) PlaylistsApiReorderOrReplacePlaylistsTracksRequest {
	r.uris = &uris
	return r
}

func (r PlaylistsApiReorderOrReplacePlaylistsTracksRequest) RequestBody(requestBody map[string]interface{}) PlaylistsApiReorderOrReplacePlaylistsTracksRequest {
	r.requestBody = &requestBody
	return r
}

func (r PlaylistsApiReorderOrReplacePlaylistsTracksRequest) Execute() (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	return r.ApiService.ReorderOrReplacePlaylistsTracksExecute(r)
}

/*
ReorderOrReplacePlaylistsTracks Update Playlist Items 

Either reorder or replace items in a playlist depending on the request's parameters.
To reorder items, include `range_start`, `insert_before`, `range_length` and `snapshot_id` in the request's body.
To replace items, include `uris` as either a query parameter or in the request's body.
Replacing items in a playlist will overwrite its existing items. This operation can be used for replacing or clearing items in a playlist.
<br/>
**Note**: Replace and reorder are mutually exclusive operations which share the same endpoint, but have different parameters.
These operations can't be applied together in a single request.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiReorderOrReplacePlaylistsTracksRequest
*/
func (a *PlaylistsApiService) ReorderOrReplacePlaylistsTracks(ctx context.Context, playlistId string) PlaylistsApiReorderOrReplacePlaylistsTracksRequest {
	return PlaylistsApiReorderOrReplacePlaylistsTracksRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
//  @return ReorderOrReplacePlaylistsTracks200Response
func (a *PlaylistsApiService) ReorderOrReplacePlaylistsTracksExecute(r PlaylistsApiReorderOrReplacePlaylistsTracksRequest) (*ReorderOrReplacePlaylistsTracks200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReorderOrReplacePlaylistsTracks200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.ReorderOrReplacePlaylistsTracks")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/tracks"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.uris != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "uris", r.uris, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PlaylistsApiUnfollowPlaylistRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
}

func (r PlaylistsApiUnfollowPlaylistRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnfollowPlaylistExecute(r)
}

/*
UnfollowPlaylist Unfollow Playlist 

Remove the current user as a follower of a playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiUnfollowPlaylistRequest
*/
func (a *PlaylistsApiService) UnfollowPlaylist(ctx context.Context, playlistId string) PlaylistsApiUnfollowPlaylistRequest {
	return PlaylistsApiUnfollowPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
func (a *PlaylistsApiService) UnfollowPlaylistExecute(r PlaylistsApiUnfollowPlaylistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.UnfollowPlaylist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/followers"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type PlaylistsApiUploadCustomPlaylistCoverRequest struct {
	ctx context.Context
	ApiService *PlaylistsApiService
	playlistId string
	body *string
}

func (r PlaylistsApiUploadCustomPlaylistCoverRequest) Body(body string) PlaylistsApiUploadCustomPlaylistCoverRequest {
	r.body = &body
	return r
}

func (r PlaylistsApiUploadCustomPlaylistCoverRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadCustomPlaylistCoverExecute(r)
}

/*
UploadCustomPlaylistCover Add Custom Playlist Cover Image 

Replace the image used to represent a specific playlist.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param playlistId
 @return PlaylistsApiUploadCustomPlaylistCoverRequest
*/
func (a *PlaylistsApiService) UploadCustomPlaylistCover(ctx context.Context, playlistId string) PlaylistsApiUploadCustomPlaylistCoverRequest {
	return PlaylistsApiUploadCustomPlaylistCoverRequest{
		ApiService: a,
		ctx: ctx,
		playlistId: playlistId,
	}
}

// Execute executes the request
func (a *PlaylistsApiService) UploadCustomPlaylistCoverExecute(r PlaylistsApiUploadCustomPlaylistCoverRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PlaylistsApiService.UploadCustomPlaylistCover")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/playlists/{playlist_id}/images"
	localVarPath = strings.Replace(localVarPath, "{"+"playlist_id"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/jpeg"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GetAnAlbum401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
